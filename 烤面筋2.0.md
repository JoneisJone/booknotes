## Java基础➕多线程➕集合➕jvm

### 基础

------

##### 面向对象的三大特性？面向对象优点？

```
封装，(属性私有化并提供外界访问方法)
继承，(子类无法访问父类的私有属性和方法，可以用自己的方式实现父类的方法)
多态(父类引用指向子类对象)
易维护，易复用，易扩展。
面向对象可能出现性能比面向过程低的情况。
```

封装	继承	多态

------

##### 重载和重写？

```
重载：同一个类中，方法名相同，参数的个数、类型、顺序不一定相同，返回值类型也可不同(但不能作为唯一不同处) 编译期
重写：子类重写父类方法，访问修饰符大于父类的，父类的private/final/static不能重写，不能抛出更多异常，构造方法不能重写 运行时期
```

重载是同一个类中可有多个同名方法；重写是子类增强父类同名方法。

------

##### **String 、StringBuilder 、StringBuffer**

```
String被final修饰，是不可变的；另外俩继承AbstractStringBuilder，可变。
线程安全：String不可变，认为线程安全；StringBuffer的一些方法加了同步锁，线程安全；StringBuilder并为加锁，非线程安全。
性能：改变String对象比如拼接是生成新对象；后俩是对原有对象本身进行操作。
总结：buffer安全，builder快一些，string更改后不是自己
```

string安全，慢；StringBuffer 安全；StringBuilder 不安全

------

##### **接口 抽象类**

```
一个类可以实现多个接口但是只能实现一个抽象类。
设计层面看：接口是对行为的抽象，是一种行为的规范；抽象是对类的抽象，是一种模板设计。
```

------

##### **hashCode()  equals()**

```
hashCode()获取哈希码，决定对象在哈希表中的位置，在散列表中有用；
equals()可以比较两对象是否为同一对象(未重写)，也可以通过重写比较是否含有相同的内容。
同一对象，一定有同一哈希码；有同一哈希码不一定是同一对象；哈希码不同一定不是同一对象。所以要用equals做比较，重写了equals()之后一定要重写hashCode()
```

https://juejin.cn/post/6844904045426016263

------

##### final

```
变量：基本数据类型初始化之后不能修改；引用类型变量初始化后不可指向另一个对象
类：类不能继承；成员方法变为final方法
```

初始化时可处理，之后不能再被修改

##### Java中的UUID类了解吗？

**[UUID原理](https://blog.csdn.net/zzhongcy/article/details/114284696?utm_term=javauuid生成原理&utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~all~sobaiduweb~default-0-114284696&spm=3001.4430)**

通用唯一标识符 Universally Unique Identifier

```java
String rowUuid = UUID.randomUUID().toString();
String uuid = rowUuid.replace("-","");
```

标准形式：32个16进制数，连字号分为5段，成为8-4-4-4-12的32个字符。加上“-”一共是36位。

规范定义包括：网卡MAC地址，时间戳，名字空间(Namespace)，伪随机数或随机数，时序等元素



### 集合

##### [HashMap线程不安全的原因？](https://blog.csdn.net/hello_cmy/article/details/105141729)

```
put时，多线程数据不一致。
1 线程1执行put操作，获得桶坐标，获得桶内链表节点头，时间片结束让出cpu；
2 线程2成功将记录插入同一个桶；
3 线程1再次被调度运行，持有过期表头并完成插入，覆盖线程2的操作，数据不一致
关键字：覆盖 数据不一致
```

```
扩容时，jdk1.7之前采用头插法，两个线程同时扩容可能造成链表循环，因为新旧链表顺序相反——
线程A即将进行扩容时，指向了一个entry元素e，中断；线程B也执行，线程B完成扩容，由于使用的是头插法，原本应该在e后面的元素现在在e之前了，回到线程A，当元素e要继续头插，原本的下一个元素已经变成了他的前驱节点，如此则会进入链表循环。
关键字：1.7 扩容 头插 链表循环
jdk1.8之后采用尾插法，并且链表长度大于8会变为红黑树。
```

```
jdk1.8扩容巧妙实现(待看懂)
```

如何解决？

```
使用HashTable替代HashMap
效率低，只能单线程处理，应为其方法被synchronized关键字修饰
```

```
使用ConcurrentHashMap
```

```
使用Collections类的synchronizedMap
```



------

##### **HashMap底层实现？**

https://zhuanlan.zhihu.com/p/21673805

```
数组➕链表
(哈希冲突时都采用拉链法/链地址法解决，但是当链表高度超过8时，1.8会将链表结构转化为红黑树结构)。Hash桶数组小，容易发生碰撞；太大则会浪费存储空间。好的解决办法就是好的Hash算法和扩容机制。由阈值和负载因子决定桶长度。桶长度是2的整数幂，目的是为了做Hash映射到桶的位置。哈希桶数组索引位置：hash算法，三步走，取key的hashCode值、高位运算、取模运算。

扩容机制的妙处：不用像1.7重新计算hash，看原来的hash值新增的bit位是0还是1，0的话索引没变，1的话索引变成“原索引+oldCap” 
```

------

##### **ConcurrentHashMap如何实现线程安全？**

```
HashMap线程不安全，在多线程操作时，一个线程引起哈希扩容时，也许会导致死循环。ConcurrentHashMap有2的幂次方个Segment对象存为一个数组，每个Segment中存在若干HashEntry键值对。与库的水平拆分类似，concurrentHashMap是一个二级哈希表。

优势：Segment之间互不影响。不同Segment可并发写入；同一Segment可以一读一写；同一Segment并发写入要上锁，一个执行一个阻塞。每个Segment自己持有锁，保证线程安全，降低锁粒度，提高并发操作效率。

在写操作时，比较所有的segment的总修改次数前后是否一致，如果一致则进行，否则重新统计。如果还是超过了，则对所有segment上锁之后再统计，写操作，释放锁。先乐观的假设修改次数都一致，如果尝试一定次数之后仍不一致，则转为悲观锁。但是1.8移除了segment。
```

https://www.jianshu.com/p/6c70d265aa7b



### 多线程

------

##### TheadLocal是什么？为什么说它会引起内存泄漏？

![image-20210510160703969](/Users/jone/Desktop/吃饭积累/面试/photos/image-20210510160703969.png)

```
每一个Thread维护一个ThreadLocalMap，key为使用弱引用的ThreadLocal实例，value为线程变量的副本。存的桶Entry,由key和value组成。
key和ThreadLocal是弱引用，value和线程变量是强引用。
key为null 被回收后，value仍然存在强引用，直到线程结束才会被回收。
```

但如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：

> Thread Ref -> Thread -> ThreaLocalMap -> Entry -> value

**key 使用弱引用**

```
当ThreadLocalMap的key为弱引用回收ThreadLocal时，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal也会被回收。当key为null，在下一次ThreadLocalMap调用set(),get()，remove()方法的时候会被清除value值。
```

```
ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。
弱引用ThreadLocal不会内存泄漏，对应的value在下一次ThreadLocalMap调用set(),get(),remove()的时候会被清除。
```

**ThreadLocal正确的使用方法**

```
每次使用完ThreadLocal都调用它的remove()方法清除数据
将ThreadLocal变量定义成private static，这样就一直存在ThreadLocal的强引用，也就能保证任何时候都能通过ThreadLocal的弱引用访问到Entry的value值，进而清除掉 
```

##### [什么是内存屏障（Memory Barrier）](https://www.cnblogs.com/lfalex0831/p/9516777.html)

内存屏障（[memory barrier](http://en.wikipedia.org/wiki/Memory_barrier)）是一个CPU指令。基本上，它是这样一条指令： 

a) 确保一些特定操作执行的顺序； 

b) 影响一些数据的可见性(可能是某些指令执行后的结果)。

编译器和CPU可以在保证输出结果一样的情况下对指令重排序，使性能得到优化。插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。

内存屏障另一个作用是强制更新一次不同CPU的缓存。例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程将得到最新值，而不用考虑到底是被哪个cpu核心或者哪颗CPU执行的。

如果你的字段是volatile，Java内存模型将在写操作后插入一个写屏障指令，在读操作前插入一个读屏障指令。这意味着如果你对一个volatile字段进行写操作 1、一旦你完成写入，任何访问这个字段的线程将会得到最新的值。2、在你写入前，会保证所有之前发生的事已经发生，并且任何更新过的数据值也是可见的，因为内存屏障会把之前的写入值都刷新到缓存。

------

##### [volatile和synchronized的区别？](https://blog.csdn.net/a347911/article/details/88379625)

总体——可见 原子 有序

可见性，什么是可见性？两个分别是如何做到的？

关键字：主存区 工作内存  工作内存更新刷主存区，主存更新刷工作区  实现——syn 解锁前工作刷新到主 加锁前清空工作&读主  volatile 内存屏障 写后加store 读后加load

原子性？syn为什么可以 volatile为什么不可以？

syn——解决多个线程间访问资源同步性。被其修饰的方法/代码块任意时刻只能有一个线程执行。使用了互斥锁，一个线程不会受到其他线程干扰。 volatile (自增操作) (1.读取a  2.a的值加一  3.结果写入a) 内存屏障(Load到Store)之间其他的cpu修改了值将会丢失。

有序性？

(分配内存；初始化；指向内存地址)

```
所以，**synchronized** 和 volatile 的**有序性与可见性**是两个角度来看的：

- **synchronized** 是因为块与块之间看起来是原子操作，块与块之间有序可见
- volatile 是在底层通过内存屏障防止指令重排的，变量前后之间的指令与指令之间有序可见

同时，**synchronized** 和 volatile 有序性不同也是因为其实现原理不同：

- **synchronized** 靠操作系统内核互斥锁实现的，相当于 JMM 中的 lock 和 unlock。退出代码块时一定会刷新变量回主内存
- volatile 靠插入内存屏障指令防止其后面的指令跑到它前面去了

总而言之就是， ***\*synchronized\** 块里的非原子操作依旧可能发生指令重排**
```

volatile禁止jvm指令重排序。

用法：syn——实例方法  静态方法/类(锁对象/监视器是这个类)  代码块 volatile只能修饰变量

```
粒度：
粒度不同，volatile关键字只能用于 变量 ；synchronized关键字可以修饰方法以及代码块和类。
阻塞：
多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞。
能否保证原子性：（自增）
volatile只能保证可见性和有序性不能保证原子性，而synchronized则三者都能保证
用途：
volatile关键字主要用于解决变量在多个线程之间的可见性，而synchronized解决的则是多个线程之间访问资源的同步性
```

说实话还是稀里糊涂

```
可见性：一个线程修改的状态对另一个线程是可见的。
原子性：操作的最小单位，不可再被分割。
有序性：代码在执行过程中的先后顺序。如果在本线程内观察，所有的操作都是有序的：如果在一个线程中观察另外一个线程，所有的线程操作都是无序的。
```

```
JVM有主内存，变量存在主内存，对线程而言是共享的。线程有自身工作内存，保存主内存某些变量的拷贝。线程之间不能直接相互访问，变量在程序中的传递，依赖主内存完成。
```

```
俩线程，修改一个变量时，为了能被另一个线程及时感知：
1.把工作内存1中更新过的共享变量，刷新到主内存中
2.将主内存中最新的共享变量的值更新到工作内存2中
```

**syn可见性？**

```
1)线程解锁前，必须把共享变量的最新值刷新到主内存中。 （解锁前写）
2)线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量时需要从主内存中重新读取最新的值(注意：加锁和解锁需要同一把锁)。 （加锁前读）
```

**Synchronized执行互斥代码的过程**

```
1)获得互斥锁
2)清空工作内存
3)从主内存拷贝变量的最新副本到工作内存
4)执行代码
5)将更改后的共享变量的值刷新到主内存
6)释放互斥锁
```

**volatile如何实现内存可见性？**

```
深入来说：通过加入内存屏障和禁止重排序优化来实现的。
1)对volatile变量执行写操作时，会在写操作后加入一条store屏障指令。
2)对volatile变量执行读操作时，会在读操作后加入一条load屏障指令。
通俗地讲：volatile变量在每次被线程访问时，
都强迫从主内存中重读该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存，
这样任何时刻，不同的线程总能看到该变量的最新值。
```

------

##### 谈谈synchronized关键字？

```
解决的是多个线程之间 访问资源的 同步性。
```

```
保证被其修饰的方法或者代码块在任意时刻只能有一个线程执行。
```

```
因为监视器锁依赖于底层操作系统Mutex Lock实现的，Java线程映射到操作系统的原生系统之上的。
线程切换/唤醒/挂起线程都需要操作系统帮忙，用户态转向核心态，时间成本高，效率低。
```

**Synchronized关键字如何使用？**

```
修饰代码块。进入同步代码块前要获得给定对象的锁。修饰实例方法。相当于给当前对象实例加锁。进入同步代码前要获得当前对象的实例锁。
修饰静态方法。给当前类加锁。会作用于所有该类的实例对象，不同线程可以访问某一实例的非静态方法，不会互斥。因为这两种情况，方法所占用的锁不同，一个是类，一个是实例对象。
```

```Java
//双重校验锁实现对象单例
public class Singleton {
    private volatile static Singleton uniqueInstance;
    private Singleton() {}
	public synchronized static Singleton getUniqueInstance() { 
  //先判断对象是否已经实例过，没有实例化过才进入加锁代码
				if (uniqueInstance == null) { //类对象加锁
            synchronized (Singleton.class) {
                if (uniqueInstance == null) {
                    uniqueInstance = new Singleton();
                }
						} 
				}
        return uniqueInstance;
	}
}
```

**为什么uniqueInstance采用volatile关键字修饰？**

```Java
uniqueInstance = new Singleton();
```

1 为uniqueInstance分配内存空间

2 初始化uniqueInstance

3 将uniqueInstance指向分配的内存地址

```
JVM指令重排特性，执行顺序可能是132.
线程2可能执行了线程1做了1、3步操作但还没做2的单例实例，发生错误。
```

synchronized和ReentrantLock的区别

```
1 两者都是可重入锁
2 syn依赖于JVM实现 Re依赖于API
3 Re功能更多 如
	等待可中断	lock.lockInterruptibly() 正在等待的线程可以选择放弃等待，处理其他事
	可实现公平锁 ReentrantLock(boolean fair)构造方法来制定是否是公平的 先等先得
	可实现选择性通知 线程注册Condition，由同一个condition实例完成线程的等待/唤醒工作，只有注册了同一个Condidion的线程们可以被该condition实例进行等待/唤醒的操作。
```



### JVM

##### JVM是什么？

```
可以运行Java代码的假想计算机，运行在不同的操作系统(Windows,Linux,macOS)之上，与硬件没有直接交互。Java源文件编译后得到字节码文件(.Class)，字节码文件又通过jvm中的解释器编译成特定机器上的机器码。
```

关键字：跨操作系统 java源文件 字节码 机器码

------

##### jvm内存里的堆和栈的区别和特点

```
线程私有：

程序计数器 「读取指令，控制代码流程；上下文切换记录执行点」 不会OOM

虚拟机栈  由栈帧组成（局部变量表，操作数栈，动态链接，方法出口）；java内存堆栈中的栈，主要泛指栈中局部变量表（原始数据类型，对象引用）；
线程请求栈深度>jvm最大深度 栈溢出异常
线程请求栈时内存不够，无法动态扩展，内存耗尽异常
调用方法——栈帧入出Java栈的过程
栈帧弹出——方法结束——return or 抛出异常

本地方法栈 用于维护本地方法

线程共享：

堆 存放对象实例，为对象实例和数组分配内存；也是垃圾收集器管理的主要区域

方法区 存储被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据
永久代是方法区的一种实现，JDK1.8将永久代替换成元空间（使用直接内存，受本机可用内存的限制）

运行时常量池 是方法区一部分，保存 字面量（文本 基本数据类型 final常量值）➕符号引用

直接内存 并非JVM运行时数据区的一部分	 
```

------

##### 说说分代垃圾回收过程

```
新生代(Eden和Survivor) 老年代 持久代➡
Eden Survivor Tenured/Old ；
Eden满了就出发Minor GC 清理无用对象，把有用对象放Survivor1或Survivor2中。MajorGC 清理老年代。FullGC，新生代，老年代都清理。具体做法：创建对象，Eden满了触发MinorGC，有用的放survivor1,等Eden再满对survivor2做相同操作，如此循环。15次之后，存活的放在Old区，达到一定比例出发MajorGC，清理老年代。Old也满了，触发FullGC
```

https://blog.csdn.net/xmj15715216140/article/details/80664630 

------

##### 什么常见情况下引起栈溢出，堆溢出？你会如何处理？

https://zhuanlan.zhihu.com/p/139166933

https://blog.csdn.net/hao134838/article/details/102866221

```
局部静态变量体积太大  如数组开大了
·加上static关键字，和类一起加载，创建类时申请资源

如函数调用层次过深，如求斐波那契数列时一直嵌套。

申请空间后未释放，垃圾太多未被清除。

设置JVM的堆内存的初始大小 
-Xms<size>
设置JVM堆内存的最大值
-Xmx<size>
```



## 计算机基础

### 计网

------

##### ping的过程经历了什么？

```
说了使用ARP协议将根据ip找到相应的mac地址，然后说ping是使用的ICMP协议。首先根据目的IP和路由表决定走哪个网卡，再根据网卡的子网掩码地址判断目的IP是否在子网内。如果存在则会通过arp缓存查询IP对应的mac地址，不存在的话会通过广播询问目的IP的mac地址，得到后就开始发包了，同时mac地址也会被arp缓存起来。
```

https://www.cnblogs.com/cherishry/p/5717387.html
https://blog.csdn.net/alexsjr/article/details/80974817

------

##### tcp是如何保证传输可靠的？

```
数据切块。包编号。

校验和(首部和数据的检验和)。丢弃重复。

流量控制。（收）
接收方有缓存空间，接收方只接收缓存空间的数据，处理不过来通知发送方降低发送速率。

拥塞控制。（发）
——发多了收不过来。发送方维持拥塞窗口(cwnd=min(cwnd,接收窗口))。
 · 慢开始 每一个传播轮次，cwnd加倍
 · 拥塞避免 每一个RTT cwnd自增1
 · 快重传
 · 快恢复 发送端接收到3个重复确认时发现丢失，立即重传丢失数据
 
超时重传。
使用定时器，不能及时收到确认将重发

ARQ协议。自动重传请求，发送方没收到接收方的确认会重传。
停止等待ARQ，发完一组就停，等确认。等不到再发，直到收到确认再发下一组。接收方收到重复分组时丢弃并发送确认。
连续ARQ，维持窗口，其内分组可以连续发送，按序达到之后确认。若有丢失则重新发丢失的，也叫后退N甄(Go-Back-N)
```

------

##### TCP/IP建立连接为什么要3次握手？

```
双方确认自己与对方的发送与接收是正常的。
```

|        | 发送端                                 | 接收端                                 |
| ------ | -------------------------------------- | -------------------------------------- |
| 第一次 | -                                      | 发送正常；接收正常                     |
| 第二次 | 发送正常，接收正常；发送正常，接收正常 | 发送正常；接收正常                     |
| 第三次 | 发送正常，接收正常；发送正常，接收正常 | 发送正常，接收正常；发送正常，接收正常 |

------

##### 断开连接后，客户端第四次挥手后为什么要等待2MSL？

```
挥手要有第四次，并且要在第四次之后等待两个单次传输时间再关闭，是为了确保如果对面没有收到，那么对面也会回传一个没有收到的消息，这个消息传输要两个单次传输时间。过了这个时间还没有收到也没有收到对面的信息，表示对面已经放弃连接，自己也可以放弃连接了。
```

------

##### 浏览器输入一个URL到返回响应的完整过程

```
浏览器查找域名的IP地址，DNS解析
TCP连接
浏览器向web服务器发送HTTP请求
服务器处理请求并发回HTTP报文
浏览器解析渲染页面
请求结束

DNS (domain name system) 域名系统，
ARP 地址解析协议 路由器与服务器通信时做的IP到MAC地址的转换
IP   建立TCP连接时收发数据在网络层使用IP协议
TCP 与服务器建立TCP连接
HTTP(hypertext transfer protocol) 超文本传输协议 TCP协议建立完成使用HTTP协议访问网页
```

------

##### UDP与TCP的区别？

![image-20210510164430724](/Users/jone/Library/Application Support/typora-user-images/image-20210510164430724.png)

```
TCP面向连接，在建立连接时需要三次握手，传递数据有流量控制，拥塞控制和超时重传等机制，传输完毕有断开连接操作——这些操作增大开销，牺牲这些处理机资源是为了传输可靠，如文件传输、收发邮件和远程登录。 

UDP无连接，不可靠交付，远地主机接收到UDP报文不需确认，主要用于通信速度高的即时通信，如语音，视频和直播。
```

------

##### DNS解析原理，使用的底层协议？

```
会先查缓存(浏览器缓存 路由器缓存 DNS缓存)，缓存没有再去递归查询。
本地域名服务器(缓存)➡根域名服务器(不做域名解析 能指路)➡顶级域名服务器(com cn)➡权威域名服务器
```

只指路不带路

------

##### tcp的拥塞控制？

```
1.慢开始 （拥塞窗口翻番）
2.拥塞避免（到达阈值后 按每个传输轮次线性自增）
3.快重传（发送端接收到3个重复确认会立即重发）
4.快恢复。（不做cwnd降为1 ssthreash减半操作；直接cwnd下降一半并线性自增）
```

------

##### https与http的区别，https是如何做到安全性的

 https://mp.weixin.qq.com/s?__biz=MzUxODAzNDg4NQ==&mid=2247483971&idx=1&sn=8f2d5dae3d95efc446061b352c8e9961&chksm=f98e46e9cef9cfff1f6bee1974b8dc27dcc42f0627dcf8ff0c0df8dbaa7a1f74587e3fafc167&cur_album_id=1337204681134751744&scene=189#rd

https://mp.weixin.qq.com/s/iSZp41SRmh5b2bXIvzemIw

```
http 
无状态（需要频繁对有关联的请求进行确认，比如购物下单，可以用cookie解决）
明文传输（信息裸奔）
不安全（明文通信被窃听；通信身份不验证，遭伪装；明文不验证完整，遭篡改）

1【安全性】HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。
2【连接性】HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。
3【端口号】HTTP 的端口号是 80，HTTPS 的端口号是 443。
4【数字证书】HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

```

##### session跨域请求和解决方案

![img](https://img2018.cnblogs.com/blog/809526/201908/809526-20190808152201872-748846747.png)

```
1.HTTP无状态，无法记录谁访问他的，session能够维护用户访问信息(如记录用户登录信息)，借助cookie的手段生成一个key为JSessionID的cookie响应给客户端，下次访问时可依据该JSessionID查找用户信息。
2.session存在服务器内存中，session过多会影响服务器性能。
```

解决方案

https://www.cnblogs.com/niuben/p/11160836.html

```
1 session sticky：同一客户端请求，落在同一台服务器上。缺点：可能造成单点压力，某一服务器有问题会一片区域的人无法访问。
2 session复制：服务器之间相互同步session信息
3 session集中存储：session集中存储在一个第三方的服务器中。要是服务器宕机则都不可用，需要集群。每次严重都要通过服务器，增加网络开销。
4 Cookie 状态信息存在客户端。会有安全问题。
5 Token 与Cookie类似，具有平台无关性，是身份令牌，在任何地方生成。
```

https://www.cnblogs.com/fxd980519/p/11321466.html

```
服务端
配置允许跨域请求：从请求中获得"Origin"请求头，对将要互通的域名之间，响应response中，做一些连接控制允许的响应头的设置。
springMVC中对所有的域名都允许，那么设置通配符为*
@CrossOrigin(allowCredentials="true", allowedHeaders = "*")

客户端
ajax中的 xhrFilds:{withCredentials:true} 保持session cookie同步
```





### 数据结构

### 算法

### 操作系统

------

##### 虚拟内存 页式存储 进程线程 快表 

```
页式存储就是页号到物理块号的转变
具体做法就是查页表中，逻辑地址页号对应的块号，因为块号是高位，第几块相当于在第几页，低位直接和页内地址做拼接（块号&页内地址）就能得到对应内存中的物理地址。
段式存储就是段号到基址的转变。
和页式存储不同，基址和段长都是不定的，此处的映射关系是基址+段内地址，而非基址&段内地址。段表中通过段号找到基址，基址+段内地址
段页式存储
用户程序先分段，每个段内部再分页。

分页内存管理面临的问题：
1 虚拟地址到物理地址转换要快 
2 如果虚拟地址空间过大，也表也会很大

快表，里面装了部分或全部页表内容，是页表的Cache。使用页表时，要先去内存查也表，找到物理地址再去内存拿东西，访问两次内存；快表只用一次。
步骤：
1 虚拟地址的页号查块表
2 若在，读取物理地址
3 不在，查页表，拿物理地址，在快表中添加映射
4 快表快满按某策略淘汰掉快表中的一个页。

```

##### O线程通信的方式 

```
线程：volatile，等待/通知机制，join方式，threadLocal
进程：管道，有名管道，信号，消息队列，信号量 ，共享内存，套接字

```

### 设计模式

#### 能举一个模式的例子吗？

**[java单例模式以及实现](https://www.cnblogs.com/cielosun/p/6582333.html)**

```
特点：
1.只有一个实例
2.单例类必须创建自己的唯一实例
3.单例类必须向其他对象提供这一实例
```

**单例模式和静态类的区别？**

1. 继承性
2. 回收时机
3. 初始化时机
4. 开销
5. 效率

```
1. 单例可以继承和被继承，方法可以被override，而静态方法不可以。
2. 静态方法中产生的对象会在执行后被释放，进而被GC清理，不会一直存在于内存中。
3. 静态类会在第一次运行时初始化，单例模式可以有其他的选择，即可以延迟加载。
4. 基于2， 3条，由于单例对象往往存在于DAO层（例如sessionFactory），如果反复的初始化和释放，则会占用很多资源，而使用单例模式将其常驻于内存可以更加节约资源。
5. 静态方法有更高的访问效率。
6. 单例模式很容易被测试
```

**实现**

1.懒汉模式

```java
public Class SingletonDemo{
  private static SingletonDemo instance;
  private SingletionDemo(){}
  public static SingletonDemo getInstance(){
    if(instance == null){
      instance = new SingletonDemo();
    }
    return instance;
  }
}
```

懒汉——lazyloading 初次使用时，需要使用才进行加载

效果：通过提供一个静态的对象instance，利用私有的构造方法向来访者提供一个单例。

缺点：未考虑线程安全，多访问者同时访问时会构造多对象。

2.线程安全的懒汉模式

```java
public Class SingletonDemo{
  private static SingletonDemo instance;
  private SingletionDemo(){}
  public static synchronized SingletonDemo getInstance(){
    if(instance == null){
      instance = new SingletonDemo();
    }
    return instance;
  }
}
```

给获得实例方法加锁，锁会额外占用资源，效率低下。

3.饿汉模式

```java
public Class SingletonDemo{
  private static SingletonDemo instance = new SingletonDemo();
  private SingletionDemo(){}
  public static SingletonDemo getInstance(){
    return instance;
  }
}
```

类加载时创建静态实例，比静态方法多了一个内存常驻，并没有lazyloading

4.静态内部类加载

```java
public class singletonDemo{
  private static class SingletonHolder{
  	private static  SingletonDemo instance = new singleDemo();
  }
  private SingletonDemo(){
    System.out.println("Singleton has loaded");
  }
  public static Singleton getInstance(){
    return SingletonHolder.instance;
  }
}
```

线程安全的，不会在类加载时就实例化对象，调用获得实例方法时才会创建，达到懒汉式效果

5.枚举方法

```java
enum SingletonDemo{
	INSTANCE,
  public void otherMethods(){
    System.out.println("Something");
  }
}
```

解决的主要问题：

(1)自由序列化

(2)保证只有一个实例

(3)线程安全

6.双重锁校验法

```java
public SingletonDemo{
  private static SingletonDemo instance;
  private SingletonDome(){
    System.out.println("loaded");
  }
  public static SingletonDemo getInstance(){
    if(instance == null){
      synchronized (SingletonDemo.class){
        if(instance == null){
          instance = new SingletonDemo();
        }
      }
    }
    return instance;
  }
}
```

某个线程获取实例时，如果没有实例化，则加锁进行实例化，保证线程安全，并且实现了lazyloading



spring中会用到哪些设计模式？



## 数据库

### Mysql

------

##### 常用的存储引擎，Innodb的优点？ 

```
支持行锁；
支持事务&崩溃后安全恢复；
支持外键；
支持多版本并发控制(MVCC)
```

------

##### 什么是索引？

```
 一种特殊的文件，包含数据库表里所有记录的指针，类似于字典的目录。
 占据物理内存空间。
 实现方式采用B树/B+树。
```

##### 索引的底层实现？ 

```
Hash索引 基于哈希表实现，每行数据对所有索引列计算hashcode，索引中保存该值和指向每行数据的指针。、 B-Tree索引 是一颗类似于平衡二叉树的树，数据分布在各个节点之中，访问速度快。     
B+Tree索引 数据都在叶子节点上，在叶子结点中增加顺序访问指针，每个叶子节点可以指向相邻叶子结点，使用双向循环链表。便于范围查找。
```

##### 聚簇索引与非聚簇索引？

```
数据与存储索引放到一块，找到索引也就找到了数据。非聚簇索引的叶子节点不存表中数据而是存主键。InnoDB查数据要根据主见再去聚簇索引内查找，该过程叫回表。一般聚簇索引查询一次，非主键索引(非聚簇索引)会回表多次。MyISAM主键索引/二级索引 都是非聚簇索引，InnoDB主键索引事聚簇索引，二级索引事非聚簇索引。
```

##### 非聚簇索引一定回表？

```
如果一个索引覆盖所有要查询字段的值，称为覆盖索引，不用回表。
```

##### 联合索引？其顺序？ 

```
多个字段同时建立一个索引。想命中，要按照建立索引时的字段顺序挨个使用，否则无法命中。
```

##### 了解最左匹配的底层原理吗 

```
 联合索引中，存储引擎会跟第一个索引列排序，单调递增；第一列定下再逐个按后续索引列制定时的顺序排序，依此构成索引树。
```

https://cloud.tencent.com/developer/article/1770563

##### 事务的隔离级别？

```
读未提交(顾名思义) 
读提交(避免脏读) 
可重复读(避免不可重复读，内容不会被修改) 
序列化(避免幻读，数量不会变多或变少) 
```

------

##### 可交叉程度？

```
脏读 不可重复读 幻读  
```

------

##### 乐观锁和悲观锁是什么？能举例谈谈嘛？

https://www.jianshu.com/p/d2ac26ca6525

```
悲观：率先做好措施，防范于未然
乐观：到时候再说吧
悲观锁在数据库中的应用，修改数据库前，先用for update加锁 （行级锁时基于索引的，sql语句与索引无关则不用行锁，而用表级锁）；而后再进行修改，如果得不到锁则等待或者返回异常。
乐观锁，可以不借用数据库的锁机制，实现可重复读。做冲突检测和数据更新即可。CAS 比较并交换。比如说，更新前查库中的某一个修改条件(版本号，已被操作次数),提交更新时看一把当前修改条件是否与取数据时的值对应相等。相等则说明没有其他线程同时处理，不想等则说明数据过期。

```



### redis



## 框架

### spring

### mybatis